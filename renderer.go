package nimsforestsmarttv

import (
	"bytes"
	"context"
	"fmt"
	"image"
	"image/jpeg"
	"sync"
)

// Renderer is the high-level API for displaying content on Smart TVs.
//
// Two display modes are supported:
//
// 1. Static Image Mode (for most DLNA TVs like JVC, Samsung, LG):
//   - Use DisplayImage() or DisplayImageJPEG() to show a static image
//   - Each call triggers a full content switch (brief transition visible)
//   - Designed for dashboards, info displays, infrequent updates
//   - Image stays displayed until explicitly changed
//
// 2. Video Streaming Mode (requires TV video streaming support):
//   - Use StreamVideo() to play HLS/video streams
//   - TV handles continuous playback internally
//   - Not supported by all TVs via DLNA
type Renderer struct {
	server *ImageServer
	mu     sync.Mutex

	// Text rendering options
	textOpts TextOptions

	// Track active sessions per TV (for smooth updates)
	activeTVs map[string]bool
}

// Option configures a Renderer
type Option func(*Renderer)

// WithTextOptions sets the default text rendering options
func WithTextOptions(opts TextOptions) Option {
	return func(r *Renderer) {
		r.textOpts = opts
	}
}

// NewRenderer creates a new Renderer with an embedded image server
func NewRenderer(opts ...Option) (*Renderer, error) {
	server, err := NewImageServer()
	if err != nil {
		return nil, fmt.Errorf("create image server: %w", err)
	}

	r := &Renderer{
		server: server,
		textOpts: TextOptions{
			FontSize:   100,
			Width:      1920,
			Height:     1080,
			Color:      White,
			Background: Black,
		},
		activeTVs: make(map[string]bool),
	}

	for _, opt := range opts {
		opt(r)
	}

	return r, nil
}

// =============================================================================
// Static Image Mode - For TVs like JVC that support DLNA image display
// =============================================================================

// DisplayImage shows a static image on the TV.
// The image remains displayed until another DisplayImage call or Stop.
// Each call triggers a content switch which may cause a brief transition.
//
// Note: Go's standard JPEG encoder may not be compatible with all TVs.
// If you encounter "file not supported" errors, use DisplayImageJPEG with
// JPEG data generated by ffmpeg+imagemagick for proper JFIF headers.
func (r *Renderer) DisplayImage(ctx context.Context, tv *TV, img image.Image) error {
	// Convert to RGBA
	bounds := img.Bounds()
	rgba := image.NewRGBA(bounds)
	for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
		for x := bounds.Min.X; x < bounds.Max.X; x++ {
			rgba.Set(x, y, img.At(x, y))
		}
	}

	// Encode as JPEG
	var buf bytes.Buffer
	if err := jpeg.Encode(&buf, rgba, &jpeg.Options{Quality: 85}); err != nil {
		return fmt.Errorf("encode JPEG: %w", err)
	}

	return r.DisplayImageJPEG(ctx, tv, buf.Bytes())
}

// DisplayImageJPEG shows a static JPEG image on the TV.
// Use this when you have pre-encoded JPEG data (e.g., from ffmpeg).
// The image remains displayed until another call or Stop.
//
// For JVC and similar TVs that require JFIF-compliant JPEGs, generate
// the JPEG using: ffmpeg -> imagemagick (magick convert)
func (r *Renderer) DisplayImageJPEG(ctx context.Context, tv *TV, jpegData []byte) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Store image on our server with unique URL
	imageURL := r.server.Store(jpegData)
	tvKey := tv.ControlURL

	// If we already have an active session, try SetNextAVTransportURI first
	// This may provide smoother transitions without "connecting" message
	if r.activeTVs[tvKey] {
		// Try to queue next image and trigger switch
		err := tv.setNextAVTransportURI(ctx, imageURL)
		if err == nil {
			// Now set it as current and play to switch
			if err := tv.setAVTransportURI(ctx, imageURL); err == nil {
				// Don't call Play - just setting URI might be enough
				// If TV doesn't update, we'll fall through to full reconnect next time
				return nil
			}
		}
		// SetNext not supported or failed, fall back to full reconnect
	}

	// Full connection: Set URI + Play
	if err := tv.setAVTransportURI(ctx, imageURL); err != nil {
		return fmt.Errorf("set URI: %w", err)
	}

	if err := tv.play(ctx); err != nil {
		return fmt.Errorf("play: %w", err)
	}

	r.activeTVs[tvKey] = true
	return nil
}

// DisplayText renders text as an image and displays it on the TV
func (r *Renderer) DisplayText(ctx context.Context, tv *TV, text string) error {
	return r.DisplayTextWithOptions(ctx, tv, text, r.textOpts)
}

// DisplayTextWithOptions renders text with custom options and displays it
func (r *Renderer) DisplayTextWithOptions(ctx context.Context, tv *TV, text string, opts TextOptions) error {
	img := RenderText(text, opts)
	return r.DisplayImage(ctx, tv, img)
}

// =============================================================================
// Video Streaming Mode - For TVs that support video playback via DLNA
// =============================================================================

// StreamVideo sends a video stream URL to the TV for continuous playback.
// Supports HLS (.m3u8), MPEG-TS, and other video formats depending on TV.
//
// Note: Many consumer TVs (including JVC VIDAA) do not support video
// streaming via DLNA AVTransport. Use Static Image Mode for these TVs.
func (r *Renderer) StreamVideo(ctx context.Context, tv *TV, videoURL string, title string) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if title == "" {
		title = "Video Stream"
	}

	// Set video URI with appropriate metadata
	if err := tv.setAVTransportURIForVideo(ctx, videoURL, title); err != nil {
		return fmt.Errorf("set video URI: %w", err)
	}

	// Start playback
	if err := tv.play(ctx); err != nil {
		return fmt.Errorf("play video: %w", err)
	}

	return nil
}

// =============================================================================
// Playback Control
// =============================================================================

// Stop stops playback on the TV
func (r *Renderer) Stop(ctx context.Context, tv *TV) error {
	return tv.stop(ctx)
}

// Close shuts down the renderer and its image server
func (r *Renderer) Close() error {
	return r.server.Close()
}

// ServerURL returns the URL of the embedded image server
func (r *Renderer) ServerURL() string {
	return r.server.URL()
}

// =============================================================================
// Deprecated - kept for backwards compatibility
// =============================================================================

// Display is deprecated. Use DisplayImage instead.
func (r *Renderer) Display(ctx context.Context, tv *TV, img image.Image) error {
	return r.DisplayImage(ctx, tv, img)
}

// DisplayJPEG is deprecated. Use DisplayImageJPEG instead.
func (r *Renderer) DisplayJPEG(ctx context.Context, tv *TV, jpegData []byte) error {
	return r.DisplayImageJPEG(ctx, tv, jpegData)
}

// DisplayHLS is deprecated. Use StreamVideo instead.
func (r *Renderer) DisplayHLS(ctx context.Context, tv *TV, hlsURL string, title string) error {
	return r.StreamVideo(ctx, tv, hlsURL, title)
}

// DisplayVideo is deprecated. Use StreamVideo instead.
func (r *Renderer) DisplayVideo(ctx context.Context, tv *TV, videoURL string, title string) error {
	return r.StreamVideo(ctx, tv, videoURL, title)
}
